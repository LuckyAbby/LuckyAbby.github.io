---
title: "C语言实现数据结构--串"
date: 2017-05-30T15:33:25+08:00
---
串即字符串，是由零个或多个字符组成的有限序列，是数据元素为单个字符的特殊线性表。

串长：串中字符的个数（n≥0）. n=0 时称为空串。空白串：由一个或多个空格符组成的串。

空串和空白串的区别是：空串(Null String)是指长度为零的串；而空白串(Blank String),是指包含一个或多个空白字符的字符串。
<!--more-->
先弄清楚几个基本概念

子串：串S中任意个连续的字符序列叫S的子串。

子串位置：子串的第一个字符在主串中的序号。

字符位置：字符在串中的序号。

串相等：串长度相等，且对应位置上字符相等。

空串是任意串的子串；任意串S都是S本身的子串，除S本身外，S的其他子串称为S的真子串。

## 串的实现与表示
首先强调：串与线性表的运算有所不同，是以“串的整体”作为操作对象，例如查找某子串，在主串某位置上插入一个子串等。
串有三种机内表示方法：

1.定长顺序存储表示：用一组地址连续的存储单元存储串值的字符序列，属静态存储方式

2.堆分配存储表示：用一组地址连续的存储单元存储串值的字符序列,但存储空间是在程序执行过程中动态分配而得。

3.串的块链存储表示：链式方式存储。其实其中1、2都属于顺序存储，3属于链式存储。

## 定长顺序存储
用一组连续的存储单元来存放串，直接使用定长的字符数组来定义，数组的上界预先给出，故称为静态存储分配。

例如：
```C
#define Maxstrlen 255    //用户可用的最大串长
typedef unsigned char SString[ Maxstrlen＋1 ] ;   
SString s;   //s 是一个可容纳255个字符的顺序串。
```
一般用SString[0]来存放串长信息;C语言约定在串尾加结束符'\0'，但不计入串长;若字符串超过Maxstrlen 则自动截断。

## 堆分配存储
堆分配存储特点：仍用一组连续的存储单元来存放串，但存储空间是在程序执行过程中动态分配而得。思路是利用malloc函数合理预设串长空间。若在操作中串值改变，还可以利用realloc函数按新串长度增加空间（即动态数组概念）。
堆T的存储结构描述：
```C
Typedef struct {
    char *ch;    //若非空串,按串长分配空间; 否则ch=NULL
    int length;  //串长度
}HString

```
## 链式存储
链式存储特点 ：用链表存储串值，易插入和删除。
其中主要有两种方法：法1：链表结点的数据分量长度取1个字符； 法2：链表结点（数据域）大小取n。很直观地就能看出法1存储密度为 < 法2存储密度。显然，若数据元素很多，用法2存储更优—称为块链结构。

## 块链的定义
```C
#define  CHUNKSIZE  80   //每块大小，可由用户定义
//首先定义结点类型
typedef struct  Chunk {
    char ch [ CHUNKSIZE ]; //每个结点中的数据域
    struct Chunk * next ;  //每个结点中的指针域
}Chunk;
//其次定义用链式存储的串类型
typedef struct {
    Chunk  *head;  //头指针
    Chunk  *tail;  //尾指针
    int  curLen;   //串的当前长度
   } Lstring;
```

## 串的模式匹配算法
算法目的：确定主串中所含子串第一次出现的位置（定位），定位问题称为串的模式匹配(Pattern Matching)，即子串定位运算，它是串处理系统中最重要的操作之一。典型函数为Index(S,T,pos)。
典型的算法有：1.BF算法--带回溯，速度慢 2.KMP算法--避免回溯，匹配速度快。

### BF算法
假设S='ababcabcacbab'，T='abcac'，pos=1，求：串T在串S中第pos个字符之后的位置。

> BF算法设计思想：
将主串S的第pos个字符和模式T的第1个字符比较，
若相等，继续逐个比较后续字符；
若不等，从主串S的下一字符（pos+1）起，重新与T第一个字符比较。  
直到主串S的一个连续子串字符序列与模式T相等,返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值0.

#### 算法的实现
```C
int Index(SString S, SString T, int pos)
{    
    int i = pos;
    int j = 1;
    while (i <= S[0] && j<=T[0])
    {
        if (S[i] == T[j])
        {
            ++i;
            ++j; //继续比较后续字符
        }
        else
        {
            i = i-j+2; //指针回溯到下一首位，重新开始匹配
            j = 1;
        }
    }
    if (j > T[0]) return i-T[0];  //子串结束，说明匹配成功
    else return 0;
}

```
#### 讨论BF算法的时间复杂度
若n为主串长度，m为子串长度，则：
(1)最好的情况—每趟不成功的匹配都发生在第一对字符比较时
如：s='aaaaaaaaaabc'；t='bc'
设匹配成功发生在si处，则字符比较次数在前面i-1趟中共比较了i-1次，第i趟成功匹配共比较了m次，因此总共比较了i-1+m次。所有成功匹配的可能共有n-m+1种。
设从si开始与t匹配成功的概率为pi，在等概率情况下pi=1/(n-m+1),因此，最好情况下平均比较次数（期望值）为：
![](http://ojzeprg7w.bkt.clouddn.com/%E4%B8%B21.JPG)
(2)最坏的情况：不成功的匹配都发生在T的最后一个字符.
每趟比较都要进行 m 次，这样比较的趟数要 n-m+1 趟，所需要比较字符的总次数为(n-m+1)m。由于m<<n，(n-m+1)m≈(n×m)。
因此，最坏的情况下的时间复杂度为 O(n×m)。

### KPM算法
改进的KPM算法，相比于BF算法来说，其改进在于：每当一趟匹配过程中出现字符比较不等时，不回溯i指针，而是利用已经得到的“部分匹配”的结果，将模式向右“滑动”尽可能远的一段距离后，继续进行比较。指针 i 没有回溯，**算法时间复杂度O(n+m)**。

为什么可以这样呢？
回顾方法一中的匹配，有几次的比较是不必进行的。因为从第三趟部分匹配的结果可看出，主串中第4、5、6个字符必然是’b','c'和'a'，因模式中的第一个字符是a，因此它无需再和这三个字符比较，而仅需将模式向右滑动三个字符的位置继续i=7，j=2时的字符比较即可。
根据这个原理，我们只要知道模式串（一般较短）中的字符比较结果并记录下来，那么在与主串中比较时，就可象上例，利用部分匹配的结果，使指针i 不回溯进行比较，将时间复杂度控制在O(n+m)的数量级上。

#### KPM算法的实现
```C
void getNext(char* t, int next[])
{
    int i=0,j=-1;
    next[0]=-1;
    while(t[i])
    {
        if(j == -1 || t[i] == t[j])
        {
            j++;i++;
            next[i]=j;
        }
        else
        {
            j=next[j];
        }
    }
}

int indexKMP(char* s, char* t, int pos)
{
    int len = strlen(t);
    int* next = (int *)malloc(sizeof(int)*len);
    int i = pos, j = 0;
    getNext(t, next);
    while(s[i] && t[j])
    {
        if(j == -1 || s[i] == t[j])
        {
            i++;j++;
        }
        else
        {
            j=next[j];
        }
    }
    if(j >= len)
    {
        return i-j;
    }
    else
    {
        return -1;
    }
}
```
欢迎指正~

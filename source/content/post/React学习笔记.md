---
title: "React学习笔记"
date: 2017-07-22T15:23:25+08:00
tags: ['React','JS']
---
想把学习 React 的一些零碎的知识点记下来，也是一些我自己的理解，可能比较琐碎，也可能比较肤浅。

在我看来，React 的一些特性主要体现在以下的几个方面：
<!-- more -->

###  组件化

组件不是一个很新的概念，之前接触过的安卓开发里面也是组件，组件意味将某个独立的功能或者页面封装起来达到复用的功能。React 认为整个页面是一个大组件，可以将其拆分成很多小组件，组件之间组合而成的整个页面，并且 React 认为组件是一个状态机器，将用户界面看成简单的状态机器，当组件处于某个状态的时候就输出对应这个状态的页面，因此我们只需要去管理每个组件的状态就好，React 会根据不同的状态去渲染 UI。

### state && props

既然 React 中页面是由一个一个组件组成的，那最基本的问题就是组件之间是如何进行数据的交换的。React 定义了 state 以及 props 进行数据的传输。

state 主要负责的与用户的交互的那部分数据变化，例如表单中的数据经常需要随着用户的输入而改变，那就应该放在 state 里面， 而 props 主要负责父子组件之间的通信传输的数据，存放的是不会随着用户的交互而变的值。例如现在你需要查询一个影院的数据，影院的id是在父组件里面拿到的，那么就应该通过 props 传递给子组件，因为这个影院的 id 值是不会在与用户的交互中变化的。

 state 一般是由这个组件内部自己去维护的，通过 setState 可以改变 state ,从而整体刷新页面，而 props 应该是由外部初始化这个组件时传递进来的。并且 props 应该是只读的数据，一旦赋值之后就不会再变化。

### JSX

JSX 是一种 JavaScript 的语法扩展，看起来很像是某种模版语言，主要是用来声明 React 当中的元素。

JSX 在 React 中**不是必须的**，但是使用之后有更好的可读性，能够构建很直观的页面。例如：
```
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);

// 不使用 JSX 的写法
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```
如上面的例子，使用 JSX 可以使页面看上去更直观，但是不使用 JSX 也可以达到这个目的。因为Babel 转义器会把 JSX 转换成一个名为 React.createElement() 的方法调用。

使用 JSX ，抛弃之前框架定义的一些模版引擎，使用代码来构建页面，让我们不需要掌握各种各样的模版语法就能直观地定义页面。

### 组件生命周期

既然说到 React 认为整个页面都是由组件组成的，那么每个组件被调用以及结束的时候都经历哪些过程就涉及到组件的生命周期。

用一张图表示组件的生命周期就是

![](http://ojzeprg7w.bkt.clouddn.com/react1.png)

其中 render 方法是会执行多次的，但是另一些方法比如 componentDidMount 只会执行一次，一般如果需要发送 Ajax 请求或者 setTimeout、setInterval就推荐在这个方法中执行（防止异步阻塞 UI），因为此时 render 方法已经执行，已经加载出 DOM 树。

shouldComponentUpdate 是一个与性能十分相关的方法，在其中可以通过比较 nextProps 与 this.props 来提供一次机会来决定是否 render，如果不两次传进来的参数相等的话就不会调用 render。

### 虚拟 DOM

我们在使用 setState 的时候，每次都是重新渲染整个页面，而没有去操作 DOM，由虚拟 DOM 来却被确保只对页面上真正变化的部分进行 DOM 操作。而背后使用的算法就是 DOM Diff 算法。 React 将 Diff 算法的时间复杂度降低到 O(n),主要是基于两个假设：
> 两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；
对于同一层次的一组子节点，它们可以通过唯一的id进行区分。

对于不同节点类型的比较，React 的处理方式是

1.如果类型不同，在树的同一位置前后输出了不同类型的节点，就直接删除掉前面的节点，创建插入新的节点。这种方式是通过逐层进行节点比较实现的。

2.如果类型相同，就会对属性进行重设定实现节点的转换。

对于不在同一层的节点，即使完全相同也会进行销毁再重建，但是在同一层的列表节点，比如要进行增删改的时候，其实是通过列表节点的 key 来保证高效的操作的。React 认为每个列表节点都有一个 key 值，这样就能识别每个节点，在进行比如插入的时候直接通过 key 就能方便地操作节点了。

---
title: "谈HTTP/1.0 /1.1 /2.0"
date: 2017-09-15T19:12:39+08:00
tags: ['HTTP','JS']
---
 HTTP 协议定义的是七层协议中的应用层，TCP 协议定义的是七层协议中的传输层。HTTP 连接是基于 TCP 的。所以很多 HTTP 协议的瓶颈都是基于 TCP 协议的。比如 TCP 建立连接初期都会慢启动（最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生），比较消耗时间。
 <!-- more -->

 ### HTTP 1.0

 HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器每次请求都需要服务器建立一个 TCP 连接，请求完之后就立即断开这个 TCP 连接。整个会话方式是：

 1.建立连接
 2.客户端发送请求
 3.服务器端发送响应消息
 4.关掉连接

 因为每次请求响应都会建立一个新的连接，每次都会导致 TCP 进行慢启动以及三次握手四次挥手，这样损失了性能。

 假设有一个应用场景。有一个页面有很多图片，这样每个图片都有一个新的 url 地址，如果每次都建立连接断开连接的话加载完这个页面可能需要很长的时间，但是其实我们每次请求的资源都十分小。如果能在一次中就传输完成，就可以避免多次 TCP 连接耗费的时长。

 而在 HTTP 1.0 没有官方的 keep alive 的操作，通常是在现有协议上添加一个指数。如果浏览器支持 keep-alive，它会在请求的包头中添加：

`Connection: Keep-Alive`

然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：

`Connection: Keep-Alive`

这样真的是太不方便了，后面就有了 HTTP 1.1 默认长连接。

### HTTP 1.1

#### 长连接模型

为了解决 HTTP 1.0 每次请求都需要开一个新的连接的缺陷， HTTP 1.1 设计了长连接的模型并默认支持，一个长连接会保持一段时间，重复用于发送一个请求，节省了新建 TCP 握手的时间。

在 HTTP 1.1 中，请求头与响应头都可能出现一个 connection 头， 这个头的含义是客户端与服务器端如何处理长连接， 决定当前的事务完成后，是否会关闭网络连接。一般双方默认是都支持长连接的。如果客户端想使用 HTTP 1.1 但是又不想支持长连接可以将 connection 设置成 close，同理服务器端也可以这样设置。一旦有一方设置这个头部为 close 之后，就表示不会使用长连接，每次请求都会打开一个新的 TCP 连接。

但是这个连接不会一直持续着，连接在空闲一段时间后会被关闭(服务器可以使用 Keep-Alive 协议头来指定一个最小的连接保持时间)。

但是这个模型也存在问题就是一个请求只能等收到另一个响应之后才能发出，因此 HTTP 1.1 又弄出来一个流水线模型

#### 流水线模型

流水线是在同一条长连接上发出连续的请求，而不用等待应答返回。这样可以避免连接延迟。理论上讲，性能还会因为两个 HTTP 请求有可能被打包到一个 TCP 消息包中而得到提升。

这种技术虽然听上去很美好，降低网络延迟，但是在各大浏览器并不是默认支持的，主要是还存在一些问题：

1.Head of line blocking(线头阻塞)

在流水线模型中客户端会不需要接受到上一个请求应答就持续发出请求，但是客户端还是需要按发送的顺序来接受响应。这样如果上一个请求需要十分长的时间来处理，比如是很大的图片，这样后续的请求都会受到影响，使得性能下降。

2.执行出错

正确的实现流水线是复杂的：传输中的资源大小，多少有效的 RTT 会被用到，还有有效带宽，流水线带来的改善有多大的影响范围。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局。

3.代理服务器可能不支持

某些服务器代理商不支持流水线模型。

用一张图片表示 HTTP 1.0的连接 HTTP 1.1的长连接以及流水线：

![](http://ojzeprg7w.bkt.clouddn.com/http.png)


### HTTP 2.0

针对上面连接的一些问题，HTTP 2.0 提出了多路复用的概念。

#### 多路复用

多路复用就是连接共享。要了解多路复用先要了解流(stream)的概念。

**流就是服务器和客户端在一个连接内用于交换帧(frame)数据的独立双向序列。**

解释几点就是：
1.流是用来交换帧的。每个流里面传输的是各种各样随机的帧，每个帧都有自己的流 id ,通过这个流 id 识别这个帧是属于哪个流的。

2.流是双向独立序列。流表达的是一次完整的资源请求-响应数据交换流程，每个 http request 都会新建自己的流，response 在同一个流上返回。在一个 HTTP/2 连接上面可以有多个流。

用一张图表示就是：
![](http://ojzeprg7w.bkt.clouddn.com/http2.png)

这样在一个 HTTP/2 连接上面可以创建多个请求响应，不用依赖建立多个 TCP 连接来实现，大大节省了时间。

### HTTP 1.0 与 HTTP 1.1 的区别

除了上面着重说的**连接**这一块的, HTTP 1.0 与 HTTP 1.1 还有下面一些区别：

1.**HOST头:**在 HTTP 1.0 中每台服务器都只绑定一个唯一的IP地址，请求消息中的 URL 并没有传递主机名。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP 1.1 的请求消息和响应消息都应支持Host头域，且请求消息中如果没有 Host 头域会抛出 400。

2.**缓存:**这个在上一篇博客有详细说过，这里就不细说了了。

3.**带宽优化:**HTTP 1.0 中不支持断点传输，如果客户端只是需要一部分数据，但是服务器还是会将整个对象传过来， 但是在 HTTP 1.1 中在请求头加了 range 头，它允许只请求资源的某个部分，返回码是206，优化了带宽。

4.**错误通知的管理:** HTTP 1.1 新增了比如 203 (Non-Authoritative Information/非官方信息)表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确，405 (Method Not Allowed/方法未允许)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。

### HTTP 1.* 的一些缺点

1.需要创建多次 TCP 连接，虽然支持 keep-alive，但是如果使用过多仍然存在性能问题，并且每次创建 TCP 连接都十分耗时。

2.HTTP 1.x 的 header 里携带的内容十分多，并且每次请求的时候都不知怎么变，增加了传输成本。

3.HTTP 1.x 传输数据都是明文，并且客户端和服务器端都无法验证对方的身份，可能无法保证数据的安全。

针对上述的一些问题， HTTP 2.0 也做了一些改进

### HTTP 2.0 的另一些改进

#### 二进制格式 (Binary Format)

HTTP 2.0 抛弃了之前使用基于文本解析的 HTTP 1.*，使用二进制格式解析，因为基于文本格式的解析存在很多缺陷，比如文本表现形式的多样性很难做到健硕性。改用二进制格式更加方便。

#### 头部压缩（Header Compression）

针对之前的 HTTP 1.* 的每次都会传输没变化的冗余头部，使得头部带有大量信息，HTTP 2.0 通过在客户端和服务器端维护一份相同的静态字典以及动态字典来减少头部的数据传输。

这里推荐博客 [HTTP/2 头部压缩技术介绍](https://imququ.com/post/header-compression-in-http2.html)

#### 服务器端推送

HTTP 2.0 允许服务器为一次客户端请求发送多个响应。通常一个网页会包含一堆额外的资源比如 CSS, JavaScript 等等，服务器端推送我们在请求这些资源之前就主动发现我们需要这些资源并返回回来，这样可以消除不必要的网络等待浪费的带宽。

### HTTPS

为了解决数据传输过程中的安全问题，网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了HTTPS，现在都是使用 TSL协议，其实是一个东西。

SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

参考资料：

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Connection_management_in_HTTP_1.x

http://www.jianshu.com/p/52d86558ca57

http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/

https://imququ.com/post/header-compression-in-http2.html

http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html

http://www.jianshu.com/p/501bf254d7e4

http://www.blogjava.net/yongboy/archive/2015/03/19/423611.html
